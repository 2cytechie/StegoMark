# 基于深度学习与DWT的水印嵌入与提取系统实现计划

## 1. 环境配置与依赖安装

* 创建 `requirements.txt` 文件，列出所有必要的依赖包

* 安装 Python 3.8+ 和所需的库（如 PyTorch、OpenCV、NumPy、scikit-image 等）

* 确保安装对抗性训练所需的额外库（如 robustbench 等，如需）

## 2. 文件结构设计

```
StegoMark/
├── data/                # 训练数据目录
│   ├── train/           # 训练集
│   │   ├── images/      # 载体图像
│   │   ├── watermark_img/ # 图像水印
│   │   └── watermark_txt/ # 文本水印
│   └── val/             # 验证集
│       ├── images/      # 载体图像
│       ├── watermark_img/ # 图像水印
│       └── watermark_txt/ # 文本水印
├── src/                 # 源代码目录
│   ├── dwt.py             # DWT变换
│   ├── models.py            # 深度学习模型
│   ├── embedding.py       # 水印嵌入算法
│   ├── extraction.py      # 水印提取算法
│   ├── utils/             # 工具函数
│   ├── evaluation.py      # 性能评估
│   └── adversarial.py     # 对抗性训练
├── scripts/             # 脚本目录
│   ├── generate_text.py # 文本文件生成脚本
│   ├── train.py         # 模型训练脚本
│   ├── test.py          # 系统测试脚本
│   └── attack_test.py   # 攻击测试脚本
├── config.py            # 参数配置
├── requirements.txt     # 依赖包列表
└── README.md            # 项目说明文档
```

## 3. 核心模块实现

### 3.1 DWT变换模块

* 实现离散小波变换（DWT）和逆离散小波变换（IDWT）

* 支持彩色图像的DWT变换

### 3.2 深度学习模型设计

* 设计用于水印嵌入的编码器网络

* 设计用于水印提取的解码器网络

* 模型支持处理图像水印和文本水印

* 设计对抗性训练框架，增强模型鲁棒性

### 3.3 水印嵌入算法

* 实现基于DWT和深度学习的水印嵌入算法，具体包含以下步骤：

  **第一步：水印预处理（统一图像与文本）**
  * 为了让一个模型同时支持图片和文本，需要将它们统一编码为二进制序列或固定尺寸的特征图
  * 文本水印：字符转 ASCII/UTF-8 二进制流，补齐至固定长度（如 64 或 256 bits）
  * 图片水印：将图片降采样或裁剪为固定尺寸（如 64x64），并进行二值化处理
  * 统一表示：最终将水印转化为形状为 (C,Hw,Ww) 的张量（张量化），以便输入神经网络

  **第二步：载体图像 DWT 分解**
  * 使用可导的 DWT（如 pytorch-wavelets）对载体图像进行一级分解，得到四个子带：
    * LL (低频)：存储主要能量，嵌入在此处鲁棒性最强，但易引起视觉失真
    * LH, HL, HH (高频)：存储边缘和细节，嵌入在此处隐蔽性好
  * 设计思路：将 DWT 的各子带作为 Encoder 的多通道输入网络

  **第三步：深度学习 Encoder 嵌入**
  * 输入：载体图像的 DWT 系数 + 预处理后的水印特征
  * 网络结构：使用残差网络（ResNet）块提取特征，将水印特征通过反卷积（ConvTranspose）或上采样调整到与 DWT 系数相同的空间维度
  * 融合：将水印特征图与 DWT 系数拼接（Concatenate），通过几层卷积层生成"残差图（Residual Map）"
  * 输出：将残差图加回原始 DWT 系数，得到含水印的 DWT 系数

  **第四步：逆离散小波变换 (IDWT)**
  * 将修改后的 DWT 系数通过 IDWT 变换回空间域，得到含水印图像 (Watermarked Image)

  **第五步：鲁棒性训练（Noise Layer）**
  * 在训练期间，在含水印图像输入 Decoder 之前，通过一个可微分的攻击模拟层
  * 加入 Gaussian 噪声、随机裁剪、高斯模糊
  * 难点：JPEG 压缩不可微。通常使用伪 JPEG 层（基于 DCT 离散余弦变换的量化近似）来实现

  **第六步：Decoder 提取水印**
  * 输入：受损的含水印图像
  * 处理：Decoder 无需原始载体（盲提取）。它可以通过空间域卷积直接预测水印，也可以先对图像做 DWT 再在频率域进行特征提取
  * 输出：重建的水印张量

* 支持彩色图片水印和文本水印两种模式

* 确保水印的不可见性

### 3.4 水印提取算法

* 实现对应的水印提取算法，与嵌入流程相呼应

* 采用盲提取方式，无需原始载体图像

* 网络结构：使用残差网络（ResNet）块提取特征，支持空间域直接预测或先进行 DWT 变换在频率域提取特征

* 输出：根据水印类型（图像或文本）进行相应的后处理，还原为原始水印形式

* 确保在不同攻击条件下仍能准确提取水印

### 3.5 对抗性训练实现

* 实现FGSM、PGD等对抗性攻击方法

* 设计对抗性训练策略，提高模型对攻击的抵抗力

* 集成可微分的攻击模拟层（Noise Layer）到训练流程中：
  * 加入 Gaussian 噪声、随机裁剪、高斯模糊
  * 实现伪 JPEG 层（基于 DCT 离散余弦变换的量化近似）来模拟 JPEG 压缩

* 在含水印图像输入 Decoder 之前应用攻击模拟，增强模型鲁棒性

* 集成对抗性训练到模型训练流程中

### 3.6 文本文件生成脚本

* 编写文本文件生成脚本

* 生成多样性的文本内容

* 将生成的txt文件保存至指定目录

## 4. 训练数据管理

* 建立清晰的训练数据组织结构

* 准备训练集和验证集

* 确保数据管理方便模型训练

* 为对抗性训练准备适当的数据增强策略

## 5. 性能评估

* 实现PSNR、SSIM等不可见性评估指标

* 实现水印提取准确率评估方法

* 测试不同攻击条件下的系统鲁棒性

* 评估对抗性训练对模型性能的提升

## 6. 系统集成与测试

* 集成所有模块

* 编写完整的测试脚本

* 进行系统测试和性能评估

* 测试对抗性训练后的模型在各种攻击下的表现

## 7. 技术要点

* 结合DWT变换和深度学习提高水印鲁棒性

* 设计灵活的模型结构支持不同类型的水印

* 实现多样化的文本水印生成

* 建立完善的性能评估体系

* 采用对抗性训练方法增强模型对攻击的抵抗力

## 8. 预期成果

* 完整的水印嵌入与提取系统代码

* 文本文件生成脚本

* 性能评估结果

* 系统测试报告

* 对抗性训练效果分析

## 9. 实现步骤

1. 环境配置与依赖安装
2. 文件结构搭建
3. DWT变换模块实现
4. 深度学习模型设计
5. 对抗性训练框架实现
6. 水印嵌入算法实现
7. 水印提取算法实现
8. 文本文件生成脚本开发
9. 训练数据准备
10. 模型训练（包含对抗性训练）
11. 系统集成与测试
12. 性能评估与分析

## 10. 注意事项

* 确保代码结构清晰，注释详细

* 遵循Python编码规范

* 注意模型训练的参数调优，特别是对抗性训练的超参数

* 确保系统在不同攻击条件下的鲁棒性

* 提供完整的测试和评估结果

* 分析对抗性训练对模型性能的影响

